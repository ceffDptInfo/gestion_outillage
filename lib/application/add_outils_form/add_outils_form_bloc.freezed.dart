// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'add_outils_form_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AddOutilsFormEventTearOff {
  const _$AddOutilsFormEventTearOff();

  _Initialized initialized() {
    return const _Initialized();
  }

  _DesignationChanged designationChanged(String designation) {
    return _DesignationChanged(
      designation,
    );
  }

  _ComplementChanged complementChanged(String complement) {
    return _ComplementChanged(
      complement,
    );
  }
}

/// @nodoc
const $AddOutilsFormEvent = _$AddOutilsFormEventTearOff();

/// @nodoc
mixin _$AddOutilsFormEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function(String designation) designationChanged,
    required TResult Function(String complement) complementChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_DesignationChanged value) designationChanged,
    required TResult Function(_ComplementChanged value) complementChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddOutilsFormEventCopyWith<$Res> {
  factory $AddOutilsFormEventCopyWith(
          AddOutilsFormEvent value, $Res Function(AddOutilsFormEvent) then) =
      _$AddOutilsFormEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AddOutilsFormEventCopyWithImpl<$Res>
    implements $AddOutilsFormEventCopyWith<$Res> {
  _$AddOutilsFormEventCopyWithImpl(this._value, this._then);

  final AddOutilsFormEvent _value;
  // ignore: unused_field
  final $Res Function(AddOutilsFormEvent) _then;
}

/// @nodoc
abstract class _$InitializedCopyWith<$Res> {
  factory _$InitializedCopyWith(
          _Initialized value, $Res Function(_Initialized) then) =
      __$InitializedCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitializedCopyWithImpl<$Res>
    extends _$AddOutilsFormEventCopyWithImpl<$Res>
    implements _$InitializedCopyWith<$Res> {
  __$InitializedCopyWithImpl(
      _Initialized _value, $Res Function(_Initialized) _then)
      : super(_value, (v) => _then(v as _Initialized));

  @override
  _Initialized get _value => super._value as _Initialized;
}

/// @nodoc

class _$_Initialized implements _Initialized {
  const _$_Initialized();

  @override
  String toString() {
    return 'AddOutilsFormEvent.initialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _Initialized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function(String designation) designationChanged,
    required TResult Function(String complement) complementChanged,
  }) {
    return initialized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
  }) {
    return initialized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
    required TResult orElse(),
  }) {
    if (initialized != null) {
      return initialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_DesignationChanged value) designationChanged,
    required TResult Function(_ComplementChanged value) complementChanged,
  }) {
    return initialized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
  }) {
    return initialized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
    required TResult orElse(),
  }) {
    if (initialized != null) {
      return initialized(this);
    }
    return orElse();
  }
}

abstract class _Initialized implements AddOutilsFormEvent {
  const factory _Initialized() = _$_Initialized;
}

/// @nodoc
abstract class _$DesignationChangedCopyWith<$Res> {
  factory _$DesignationChangedCopyWith(
          _DesignationChanged value, $Res Function(_DesignationChanged) then) =
      __$DesignationChangedCopyWithImpl<$Res>;
  $Res call({String designation});
}

/// @nodoc
class __$DesignationChangedCopyWithImpl<$Res>
    extends _$AddOutilsFormEventCopyWithImpl<$Res>
    implements _$DesignationChangedCopyWith<$Res> {
  __$DesignationChangedCopyWithImpl(
      _DesignationChanged _value, $Res Function(_DesignationChanged) _then)
      : super(_value, (v) => _then(v as _DesignationChanged));

  @override
  _DesignationChanged get _value => super._value as _DesignationChanged;

  @override
  $Res call({
    Object? designation = freezed,
  }) {
    return _then(_DesignationChanged(
      designation == freezed
          ? _value.designation
          : designation // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_DesignationChanged implements _DesignationChanged {
  const _$_DesignationChanged(this.designation);

  @override
  final String designation;

  @override
  String toString() {
    return 'AddOutilsFormEvent.designationChanged(designation: $designation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _DesignationChanged &&
            const DeepCollectionEquality()
                .equals(other.designation, designation));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(designation));

  @JsonKey(ignore: true)
  @override
  _$DesignationChangedCopyWith<_DesignationChanged> get copyWith =>
      __$DesignationChangedCopyWithImpl<_DesignationChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function(String designation) designationChanged,
    required TResult Function(String complement) complementChanged,
  }) {
    return designationChanged(designation);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
  }) {
    return designationChanged?.call(designation);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
    required TResult orElse(),
  }) {
    if (designationChanged != null) {
      return designationChanged(designation);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_DesignationChanged value) designationChanged,
    required TResult Function(_ComplementChanged value) complementChanged,
  }) {
    return designationChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
  }) {
    return designationChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
    required TResult orElse(),
  }) {
    if (designationChanged != null) {
      return designationChanged(this);
    }
    return orElse();
  }
}

abstract class _DesignationChanged implements AddOutilsFormEvent {
  const factory _DesignationChanged(String designation) = _$_DesignationChanged;

  String get designation;
  @JsonKey(ignore: true)
  _$DesignationChangedCopyWith<_DesignationChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ComplementChangedCopyWith<$Res> {
  factory _$ComplementChangedCopyWith(
          _ComplementChanged value, $Res Function(_ComplementChanged) then) =
      __$ComplementChangedCopyWithImpl<$Res>;
  $Res call({String complement});
}

/// @nodoc
class __$ComplementChangedCopyWithImpl<$Res>
    extends _$AddOutilsFormEventCopyWithImpl<$Res>
    implements _$ComplementChangedCopyWith<$Res> {
  __$ComplementChangedCopyWithImpl(
      _ComplementChanged _value, $Res Function(_ComplementChanged) _then)
      : super(_value, (v) => _then(v as _ComplementChanged));

  @override
  _ComplementChanged get _value => super._value as _ComplementChanged;

  @override
  $Res call({
    Object? complement = freezed,
  }) {
    return _then(_ComplementChanged(
      complement == freezed
          ? _value.complement
          : complement // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ComplementChanged implements _ComplementChanged {
  const _$_ComplementChanged(this.complement);

  @override
  final String complement;

  @override
  String toString() {
    return 'AddOutilsFormEvent.complementChanged(complement: $complement)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ComplementChanged &&
            const DeepCollectionEquality()
                .equals(other.complement, complement));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(complement));

  @JsonKey(ignore: true)
  @override
  _$ComplementChangedCopyWith<_ComplementChanged> get copyWith =>
      __$ComplementChangedCopyWithImpl<_ComplementChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialized,
    required TResult Function(String designation) designationChanged,
    required TResult Function(String complement) complementChanged,
  }) {
    return complementChanged(complement);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
  }) {
    return complementChanged?.call(complement);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialized,
    TResult Function(String designation)? designationChanged,
    TResult Function(String complement)? complementChanged,
    required TResult orElse(),
  }) {
    if (complementChanged != null) {
      return complementChanged(complement);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initialized value) initialized,
    required TResult Function(_DesignationChanged value) designationChanged,
    required TResult Function(_ComplementChanged value) complementChanged,
  }) {
    return complementChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
  }) {
    return complementChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initialized value)? initialized,
    TResult Function(_DesignationChanged value)? designationChanged,
    TResult Function(_ComplementChanged value)? complementChanged,
    required TResult orElse(),
  }) {
    if (complementChanged != null) {
      return complementChanged(this);
    }
    return orElse();
  }
}

abstract class _ComplementChanged implements AddOutilsFormEvent {
  const factory _ComplementChanged(String complement) = _$_ComplementChanged;

  String get complement;
  @JsonKey(ignore: true)
  _$ComplementChangedCopyWith<_ComplementChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AddOutilsFormStateTearOff {
  const _$AddOutilsFormStateTearOff();

  _AddOutilsFormState call(
      {required Designation designation,
      required Complement complement,
      required bool showErrorMessages,
      required bool isEditing,
      required bool isSaving,
      required Option<Either<OutilsFailure, Unit>>
          saveFailureOrSuccessOption}) {
    return _AddOutilsFormState(
      designation: designation,
      complement: complement,
      showErrorMessages: showErrorMessages,
      isEditing: isEditing,
      isSaving: isSaving,
      saveFailureOrSuccessOption: saveFailureOrSuccessOption,
    );
  }
}

/// @nodoc
const $AddOutilsFormState = _$AddOutilsFormStateTearOff();

/// @nodoc
mixin _$AddOutilsFormState {
  Designation get designation => throw _privateConstructorUsedError;
  Complement get complement => throw _privateConstructorUsedError;
  bool get showErrorMessages => throw _privateConstructorUsedError;
  bool get isEditing => throw _privateConstructorUsedError;
  bool get isSaving => throw _privateConstructorUsedError;
  Option<Either<OutilsFailure, Unit>> get saveFailureOrSuccessOption =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AddOutilsFormStateCopyWith<AddOutilsFormState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddOutilsFormStateCopyWith<$Res> {
  factory $AddOutilsFormStateCopyWith(
          AddOutilsFormState value, $Res Function(AddOutilsFormState) then) =
      _$AddOutilsFormStateCopyWithImpl<$Res>;
  $Res call(
      {Designation designation,
      Complement complement,
      bool showErrorMessages,
      bool isEditing,
      bool isSaving,
      Option<Either<OutilsFailure, Unit>> saveFailureOrSuccessOption});
}

/// @nodoc
class _$AddOutilsFormStateCopyWithImpl<$Res>
    implements $AddOutilsFormStateCopyWith<$Res> {
  _$AddOutilsFormStateCopyWithImpl(this._value, this._then);

  final AddOutilsFormState _value;
  // ignore: unused_field
  final $Res Function(AddOutilsFormState) _then;

  @override
  $Res call({
    Object? designation = freezed,
    Object? complement = freezed,
    Object? showErrorMessages = freezed,
    Object? isEditing = freezed,
    Object? isSaving = freezed,
    Object? saveFailureOrSuccessOption = freezed,
  }) {
    return _then(_value.copyWith(
      designation: designation == freezed
          ? _value.designation
          : designation // ignore: cast_nullable_to_non_nullable
              as Designation,
      complement: complement == freezed
          ? _value.complement
          : complement // ignore: cast_nullable_to_non_nullable
              as Complement,
      showErrorMessages: showErrorMessages == freezed
          ? _value.showErrorMessages
          : showErrorMessages // ignore: cast_nullable_to_non_nullable
              as bool,
      isEditing: isEditing == freezed
          ? _value.isEditing
          : isEditing // ignore: cast_nullable_to_non_nullable
              as bool,
      isSaving: isSaving == freezed
          ? _value.isSaving
          : isSaving // ignore: cast_nullable_to_non_nullable
              as bool,
      saveFailureOrSuccessOption: saveFailureOrSuccessOption == freezed
          ? _value.saveFailureOrSuccessOption
          : saveFailureOrSuccessOption // ignore: cast_nullable_to_non_nullable
              as Option<Either<OutilsFailure, Unit>>,
    ));
  }
}

/// @nodoc
abstract class _$AddOutilsFormStateCopyWith<$Res>
    implements $AddOutilsFormStateCopyWith<$Res> {
  factory _$AddOutilsFormStateCopyWith(
          _AddOutilsFormState value, $Res Function(_AddOutilsFormState) then) =
      __$AddOutilsFormStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Designation designation,
      Complement complement,
      bool showErrorMessages,
      bool isEditing,
      bool isSaving,
      Option<Either<OutilsFailure, Unit>> saveFailureOrSuccessOption});
}

/// @nodoc
class __$AddOutilsFormStateCopyWithImpl<$Res>
    extends _$AddOutilsFormStateCopyWithImpl<$Res>
    implements _$AddOutilsFormStateCopyWith<$Res> {
  __$AddOutilsFormStateCopyWithImpl(
      _AddOutilsFormState _value, $Res Function(_AddOutilsFormState) _then)
      : super(_value, (v) => _then(v as _AddOutilsFormState));

  @override
  _AddOutilsFormState get _value => super._value as _AddOutilsFormState;

  @override
  $Res call({
    Object? designation = freezed,
    Object? complement = freezed,
    Object? showErrorMessages = freezed,
    Object? isEditing = freezed,
    Object? isSaving = freezed,
    Object? saveFailureOrSuccessOption = freezed,
  }) {
    return _then(_AddOutilsFormState(
      designation: designation == freezed
          ? _value.designation
          : designation // ignore: cast_nullable_to_non_nullable
              as Designation,
      complement: complement == freezed
          ? _value.complement
          : complement // ignore: cast_nullable_to_non_nullable
              as Complement,
      showErrorMessages: showErrorMessages == freezed
          ? _value.showErrorMessages
          : showErrorMessages // ignore: cast_nullable_to_non_nullable
              as bool,
      isEditing: isEditing == freezed
          ? _value.isEditing
          : isEditing // ignore: cast_nullable_to_non_nullable
              as bool,
      isSaving: isSaving == freezed
          ? _value.isSaving
          : isSaving // ignore: cast_nullable_to_non_nullable
              as bool,
      saveFailureOrSuccessOption: saveFailureOrSuccessOption == freezed
          ? _value.saveFailureOrSuccessOption
          : saveFailureOrSuccessOption // ignore: cast_nullable_to_non_nullable
              as Option<Either<OutilsFailure, Unit>>,
    ));
  }
}

/// @nodoc

class _$_AddOutilsFormState implements _AddOutilsFormState {
  const _$_AddOutilsFormState(
      {required this.designation,
      required this.complement,
      required this.showErrorMessages,
      required this.isEditing,
      required this.isSaving,
      required this.saveFailureOrSuccessOption});

  @override
  final Designation designation;
  @override
  final Complement complement;
  @override
  final bool showErrorMessages;
  @override
  final bool isEditing;
  @override
  final bool isSaving;
  @override
  final Option<Either<OutilsFailure, Unit>> saveFailureOrSuccessOption;

  @override
  String toString() {
    return 'AddOutilsFormState(designation: $designation, complement: $complement, showErrorMessages: $showErrorMessages, isEditing: $isEditing, isSaving: $isSaving, saveFailureOrSuccessOption: $saveFailureOrSuccessOption)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AddOutilsFormState &&
            const DeepCollectionEquality()
                .equals(other.designation, designation) &&
            const DeepCollectionEquality()
                .equals(other.complement, complement) &&
            const DeepCollectionEquality()
                .equals(other.showErrorMessages, showErrorMessages) &&
            const DeepCollectionEquality().equals(other.isEditing, isEditing) &&
            const DeepCollectionEquality().equals(other.isSaving, isSaving) &&
            const DeepCollectionEquality().equals(
                other.saveFailureOrSuccessOption, saveFailureOrSuccessOption));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(designation),
      const DeepCollectionEquality().hash(complement),
      const DeepCollectionEquality().hash(showErrorMessages),
      const DeepCollectionEquality().hash(isEditing),
      const DeepCollectionEquality().hash(isSaving),
      const DeepCollectionEquality().hash(saveFailureOrSuccessOption));

  @JsonKey(ignore: true)
  @override
  _$AddOutilsFormStateCopyWith<_AddOutilsFormState> get copyWith =>
      __$AddOutilsFormStateCopyWithImpl<_AddOutilsFormState>(this, _$identity);
}

abstract class _AddOutilsFormState implements AddOutilsFormState {
  const factory _AddOutilsFormState(
      {required Designation designation,
      required Complement complement,
      required bool showErrorMessages,
      required bool isEditing,
      required bool isSaving,
      required Option<Either<OutilsFailure, Unit>>
          saveFailureOrSuccessOption}) = _$_AddOutilsFormState;

  @override
  Designation get designation;
  @override
  Complement get complement;
  @override
  bool get showErrorMessages;
  @override
  bool get isEditing;
  @override
  bool get isSaving;
  @override
  Option<Either<OutilsFailure, Unit>> get saveFailureOrSuccessOption;
  @override
  @JsonKey(ignore: true)
  _$AddOutilsFormStateCopyWith<_AddOutilsFormState> get copyWith =>
      throw _privateConstructorUsedError;
}
